// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: snapshots.sql

package dbsqlc

import (
	"context"
)

const createSnapshot = `-- name: CreateSnapshot :execlastid
INSERT INTO snapshots (application, name, trigger_component, trigger_git_sha, trigger_pipeline_run, tests_passed, released, release_blocked_reason, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateSnapshotParams struct {
	Application          string
	Name                 string
	TriggerComponent     string
	TriggerGitSha        string
	TriggerPipelineRun   string
	TestsPassed          int64
	Released             int64
	ReleaseBlockedReason string
	CreatedAt            string
}

func (q *Queries) CreateSnapshot(ctx context.Context, arg CreateSnapshotParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createSnapshot,
		arg.Application,
		arg.Name,
		arg.TriggerComponent,
		arg.TriggerGitSha,
		arg.TriggerPipelineRun,
		arg.TestsPassed,
		arg.Released,
		arg.ReleaseBlockedReason,
		arg.CreatedAt,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createSnapshotComponent = `-- name: CreateSnapshotComponent :exec
INSERT INTO snapshot_components (snapshot_id, component, git_sha, image_url, git_url)
VALUES (?, ?, ?, ?, ?)
`

type CreateSnapshotComponentParams struct {
	SnapshotID int64
	Component  string
	GitSha     string
	ImageUrl   string
	GitUrl     string
}

func (q *Queries) CreateSnapshotComponent(ctx context.Context, arg CreateSnapshotComponentParams) error {
	_, err := q.db.ExecContext(ctx, createSnapshotComponent,
		arg.SnapshotID,
		arg.Component,
		arg.GitSha,
		arg.ImageUrl,
		arg.GitUrl,
	)
	return err
}

const createSnapshotTestResult = `-- name: CreateSnapshotTestResult :exec
INSERT INTO snapshot_test_results (snapshot_id, scenario, status, pipeline_run, total, passed, failed, skipped, duration_sec)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateSnapshotTestResultParams struct {
	SnapshotID  int64
	Scenario    string
	Status      string
	PipelineRun string
	Total       int64
	Passed      int64
	Failed      int64
	Skipped     int64
	DurationSec float64
}

func (q *Queries) CreateSnapshotTestResult(ctx context.Context, arg CreateSnapshotTestResultParams) error {
	_, err := q.db.ExecContext(ctx, createSnapshotTestResult,
		arg.SnapshotID,
		arg.Scenario,
		arg.Status,
		arg.PipelineRun,
		arg.Total,
		arg.Passed,
		arg.Failed,
		arg.Skipped,
		arg.DurationSec,
	)
	return err
}

const getSnapshotRow = `-- name: GetSnapshotRow :one
SELECT id, application, name, trigger_component, trigger_git_sha, trigger_pipeline_run,
       tests_passed, released, release_blocked_reason, created_at
FROM snapshots WHERE name = ?
`

func (q *Queries) GetSnapshotRow(ctx context.Context, name string) (Snapshot, error) {
	row := q.db.QueryRowContext(ctx, getSnapshotRow, name)
	var i Snapshot
	err := row.Scan(
		&i.ID,
		&i.Application,
		&i.Name,
		&i.TriggerComponent,
		&i.TriggerGitSha,
		&i.TriggerPipelineRun,
		&i.TestsPassed,
		&i.Released,
		&i.ReleaseBlockedReason,
		&i.CreatedAt,
	)
	return i, err
}

const latestSnapshotPerApplication = `-- name: LatestSnapshotPerApplication :many
SELECT s.id, s.application, s.name, s.trigger_component, s.trigger_git_sha, s.trigger_pipeline_run,
       s.tests_passed, s.released, s.release_blocked_reason, s.created_at, CAST(counts.cnt AS INTEGER) AS cnt
FROM snapshots s
JOIN (
    SELECT application, MAX(id) AS max_id, COUNT(*) AS cnt
    FROM snapshots
    GROUP BY application
) counts ON s.id = counts.max_id
ORDER BY s.application
`

type LatestSnapshotPerApplicationRow struct {
	ID                   int64
	Application          string
	Name                 string
	TriggerComponent     string
	TriggerGitSha        string
	TriggerPipelineRun   string
	TestsPassed          int64
	Released             int64
	ReleaseBlockedReason string
	CreatedAt            string
	Cnt                  int64
}

func (q *Queries) LatestSnapshotPerApplication(ctx context.Context) ([]LatestSnapshotPerApplicationRow, error) {
	rows, err := q.db.QueryContext(ctx, latestSnapshotPerApplication)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LatestSnapshotPerApplicationRow
	for rows.Next() {
		var i LatestSnapshotPerApplicationRow
		if err := rows.Scan(
			&i.ID,
			&i.Application,
			&i.Name,
			&i.TriggerComponent,
			&i.TriggerGitSha,
			&i.TriggerPipelineRun,
			&i.TestsPassed,
			&i.Released,
			&i.ReleaseBlockedReason,
			&i.CreatedAt,
			&i.Cnt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllSnapshots = `-- name: ListAllSnapshots :many
SELECT id, application, name, trigger_component, trigger_git_sha, trigger_pipeline_run,
       tests_passed, released, release_blocked_reason, created_at
FROM snapshots
ORDER BY id DESC LIMIT ? OFFSET ?
`

type ListAllSnapshotsParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) ListAllSnapshots(ctx context.Context, arg ListAllSnapshotsParams) ([]Snapshot, error) {
	rows, err := q.db.QueryContext(ctx, listAllSnapshots, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Snapshot
	for rows.Next() {
		var i Snapshot
		if err := rows.Scan(
			&i.ID,
			&i.Application,
			&i.Name,
			&i.TriggerComponent,
			&i.TriggerGitSha,
			&i.TriggerPipelineRun,
			&i.TestsPassed,
			&i.Released,
			&i.ReleaseBlockedReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSnapshotComponents = `-- name: ListSnapshotComponents :many
SELECT id, snapshot_id, component, git_sha, image_url, git_url
FROM snapshot_components
WHERE snapshot_id = ?
ORDER BY component
`

func (q *Queries) ListSnapshotComponents(ctx context.Context, snapshotID int64) ([]SnapshotComponent, error) {
	rows, err := q.db.QueryContext(ctx, listSnapshotComponents, snapshotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SnapshotComponent
	for rows.Next() {
		var i SnapshotComponent
		if err := rows.Scan(
			&i.ID,
			&i.SnapshotID,
			&i.Component,
			&i.GitSha,
			&i.ImageUrl,
			&i.GitUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSnapshotTestResults = `-- name: ListSnapshotTestResults :many
SELECT id, snapshot_id, scenario, status, pipeline_run, total, passed, failed, skipped, duration_sec, created_at
FROM snapshot_test_results
WHERE snapshot_id = ?
ORDER BY scenario
`

func (q *Queries) ListSnapshotTestResults(ctx context.Context, snapshotID int64) ([]SnapshotTestResult, error) {
	rows, err := q.db.QueryContext(ctx, listSnapshotTestResults, snapshotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SnapshotTestResult
	for rows.Next() {
		var i SnapshotTestResult
		if err := rows.Scan(
			&i.ID,
			&i.SnapshotID,
			&i.Scenario,
			&i.Status,
			&i.PipelineRun,
			&i.Total,
			&i.Passed,
			&i.Failed,
			&i.Skipped,
			&i.DurationSec,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSnapshotsByApplication = `-- name: ListSnapshotsByApplication :many
SELECT id, application, name, trigger_component, trigger_git_sha, trigger_pipeline_run,
       tests_passed, released, release_blocked_reason, created_at
FROM snapshots
WHERE application = ?
ORDER BY id DESC LIMIT ? OFFSET ?
`

type ListSnapshotsByApplicationParams struct {
	Application string
	Limit       int64
	Offset      int64
}

func (q *Queries) ListSnapshotsByApplication(ctx context.Context, arg ListSnapshotsByApplicationParams) ([]Snapshot, error) {
	rows, err := q.db.QueryContext(ctx, listSnapshotsByApplication, arg.Application, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Snapshot
	for rows.Next() {
		var i Snapshot
		if err := rows.Scan(
			&i.ID,
			&i.Application,
			&i.Name,
			&i.TriggerComponent,
			&i.TriggerGitSha,
			&i.TriggerPipelineRun,
			&i.TestsPassed,
			&i.Released,
			&i.ReleaseBlockedReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const snapshotExistsByName = `-- name: SnapshotExistsByName :one
SELECT COUNT(*) FROM snapshots WHERE name = ?
`

func (q *Queries) SnapshotExistsByName(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, snapshotExistsByName, name)
	var count int64
	err := row.Scan(&count)
	return count, err
}
